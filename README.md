# ece463-563-project-2--branch-prediction-solved
**TO GET THIS SOLUTION VISIT:** [ECE463-563 Project #2- Branch Prediction Solved](https://www.ankitcodinghub.com/product/ece463-563-project-2-branch-prediction-version-1-0-solved/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;126437&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;5&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (5 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;ECE463-563 Project #2- Branch Prediction Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (5 votes)    </div>
    </div>
They must do this (design and write their source code) without the assistance of any other person in ECE 463/563 or not in ECE 463/563.&nbsp; They must do this (design and write their source code) without searching the web for past semesters‚Äô projects and without searching the web for source code with similar goals (<em>e.g.</em>, modeling computer architecture components such as caches, predictors, pipelines, <em>etc</em>.), which is strictly forbidden.&nbsp; They must do this (design and write their source code) without looking at anyone else‚Äôs source code, without obtaining electronic or printed copies of anyone else‚Äôs source code, <em>etc</em>.&nbsp; Use of ChatGPT or other generative AI tools is prohibited. o <strong>Explicit debugging:</strong> With respect to ‚Äúexplicit debugging‚Äù as part of the coding process (<em>e.g.</em>, using a debugger, inspecting code for bugs, inserting prints in the code, iteratively applying fixes, <em>etc</em>.), each student must explicitly debug their code without the assistance of any other person in ECE 463/563 or not in ECE 463/563. o <strong>Report:</strong> Each student must run their own experiments, collect and process their own data, and write their own report.&nbsp; Plagiarism (lifting text, graphs, illustrations, <em>etc</em>., from someone else, whether one adjusts the originals or not) is prohibited.&nbsp; Using someone else‚Äôs data (in raw form and/or graph form) is prohibited.&nbsp; Fabricating data is prohibited. o <strong>Sanctions:</strong> The sanctions for violating the academic integrity policy are (1) a score of 0 on the project and (2) academic integrity probation for a first-time offense or suspension for a subsequent offense (the latter sanctions are administered by the Office of Student Conduct).&nbsp; Note that, when it comes to academic integrity violations, both the giver and receiver of aid are responsible and both are sanctioned.&nbsp; Please see the following RAIV form which has links to various policies and procedures and gives a sense of how academic integrity violations are confronted, documented, and sanctioned: <a href="https://go.ncsu.edu/RAIV">RAIV form</a><a href="https://go.ncsu.edu/RAIV">.</a>&nbsp; o <strong>Enforcement:</strong> The TAs will scan source code (from current and past semesters) through tools available to us for detecting cheating. The outputs from these tools, combined with in-depth manual analysis of these outputs, will be the basis for investigating suspected academic integrity violations.&nbsp; TAs will identify suspected plagiarism and/or data fabrication and these cases will be investigated.

<ul>
<li>Reasonable assistance: If a student has any doubts or questions, or if a student is stumped by a bug, the student is encouraged to seek assistance using both of the following channels. o Students may receive assistance from the TAs and instructor. o Students are encouraged to post their doubts, questions, and obstacles, on the Moodle message board for this project.&nbsp; The instructor and TAs will moderate the message board to ensure that reasonable assistance is provided to the student.&nbsp; To strictly abide by the ‚Äúno collaboration policy‚Äù, students may not reply to other students‚Äô project queries unless the instructor solicits input from other students for a particular query.
<ul>
<li>An example of reasonable assistance via the message board: Student A: ‚Äú<em>I‚Äôm encountering the following problem: I‚Äôm getting fewer writebacks from L2 to main memory than the validation runs. What might I be doing wrong?</em>‚Äù Instructor/TA: ‚Äú<em>Maybe you have implemented evictions in more than one place in your code rather than consolidating it into one place (efficient and less bug-prone).&nbsp; If so, make sure you are checking for and counting evicted dirty blocks at all such locations (or try to implement evictions at one place in the code).</em>‚Äù</li>
<li>Another example of a reasonable exchange: Student A: ‚Äú<em>I‚Äôm unsure how to split the address into tag and index, and how to discard the block offset bits. I‚Äôve successfully computed the # bits for each but I am stuck on how to manipulate the address in C/C++. Do you have any advice?</em>‚Äù Instructor/TA: ‚Äú<em>We suggest you use an unsigned integer type for the address and use bitwise manipulation, such as ANDs (&amp;), ORs (|), and left/right shifts (&lt;&lt;. &gt;&gt;) to extract values from the unsigned integer, the same as one would do in Verilog.</em>‚Äù</li>
<li>Another example of a reasonable exchange: Student A: ‚Äú<em>I‚Äôm unsure how to dynamically allocate memory, such as dynamically allocating a 1D array of structs/classes or (more appropriately for a cache) a 2D array of structs/classes. Can you point me to some references on this?</em>‚Äù Instructor/TA: ‚Äú<em>Sure, here is a web site or reference book that discusses dynamic memory allocation including 1D and 2D arrays.</em>‚Äù</li>
</ul>
</li>
</ul>
<h2>1.2.&nbsp;&nbsp;&nbsp; Reduced project scope for ECE 463 students</h2>
The project scope is reduced <u>but still substantial</u> for ECE 463 students, as detailed in this specification.

<h2>1.3.&nbsp;&nbsp;&nbsp; Programming languages for this project</h2>
You must implement your project using the C, C++, or Java languages, for two reasons. First, these languages are preferred for computer architecture performance modeling. Second, our Gradescope autograder only supports compilation of these languages.

<h2>1.4.&nbsp;&nbsp;&nbsp; Responsibility for self-grading your project via Gradescope</h2>
<u>You will submit, validate, and SELF-GRADE your project via Gradescope; the TAs will only</u> <u>manually grade the report. While you are developing your simulator, you are required to</u> <u>frequently check via Gradescope that your code compiles, runs, and gives expected outputs with</u> <u>respect to your current progress. This is necessary to resolve porting issues in a timely fashion</u> <u>(<em>i.e.</em>, well before the deadline), caused by different compiler versions in your programming</u> <u>environment and the Gradescope backend. This is also necessary to resolve non-compliance</u> <u>issues (<em>i.e.</em>, how you specify the simulator‚Äôs command-line arguments, how you format the</u> <u>simulator‚Äôs outputs, <em>etc</em>.) in a timely fashion (<em>i.e.</em>, well before the deadline).</u>

&nbsp;

<h1>2.&nbsp; Project Description</h1>
In this project, you will construct a branch predictor simulator and use it to evaluate different configurations of branch predictors.

<h1>3.&nbsp; Simulator Specification</h1>
<h2>3.1.&nbsp;&nbsp;&nbsp; ECE 463 and ECE 563 students: Branch predictors</h2>
Model a <em>gshare</em> branch predictor with parameters {<em>m</em>, <em>n</em>}, where: o <em>m</em> is the number of low-order PC bits used to form the prediction table index.&nbsp; <strong>Note</strong>: discard the lowest two bits of the PC, since these are always zero, <em>i.e</em>., use bits <strong><em>m</em>+1</strong> through <strong>2</strong> of the PC.

o <em>n</em> is the number of bits in the global branch history register.&nbsp; <strong>Note</strong>: <em>n</em> ÔÇ£ <em>m</em>.&nbsp; <strong>Note</strong>: <em>n</em> may equal zero, in which case we have the simple <em>bimodal</em> branch predictor.

<h3>3.1.1.&nbsp;&nbsp;&nbsp; n=0: bimodal branch predictor</h3>
When n=0, the <em>gshare</em> predictor reduces to a simple <em>bimodal</em> predictor. In this case, the index is based on only the branch‚Äôs PC, as shown in Fig. 1 below.

&nbsp;

<u>Entry in the prediction table:</u>

An entry in the prediction table contains a single 2-bit counter. All entries in the prediction table should be initialized to <strong>2</strong> (‚Äúweakly taken‚Äù) when the simulation begins.

&nbsp;

<u>Regarding branch interference:</u> Different branches may index the same entry in the prediction table. This is called ‚Äúinterference‚Äù. Interference is not explicitly detected or avoided: it just happens. (There is no tag array, no tag checking, and no ‚Äúmiss‚Äù signal for the prediction table!)

&nbsp;

<u>Steps:</u>

When you get a branch from the trace file, there are three steps:

<ul>
<li>Determine the branch‚Äôs <strong>index</strong> into the prediction table.</li>
<li>Make a prediction. Use <strong>index</strong> to get the branch‚Äôs counter from the prediction table. If the counter value is greater than or equal to <strong>2</strong>, then the branch is predicted <em>taken</em>, else it is predicted <em>not-taken</em>.</li>
<li>Update the branch predictor based on the branch‚Äôs actual outcome. The branch‚Äôs counter in the prediction table is incremented if the branch was taken, decremented if the branch was nottaken. The counter <em>saturates </em>at the extremes (<strong>0</strong> and <strong>3</strong>), however.</li>
</ul>
&nbsp;

<strong>Figure 1.&nbsp; Bimodal branch predictor. </strong>

<h3>3.1.2.&nbsp;&nbsp;&nbsp; n&gt;0: gshare branch predictor</h3>
When n &gt; 0, there is an n-bit global branch history register. In this case, the index is based on both the branch‚Äôs PC and the global branch history register, as shown in Fig. 2 below. The global branch history register is initialized to all zeroes (00‚Ä¶0) at the beginning of the simulation.

&nbsp;

<u>Steps:</u>

When you get a branch from the trace file, there are four steps:

<ul>
<li>Determine the branch‚Äôs <strong>index</strong> into the prediction table. Fig. 2 shows how to generate the index: the current n-bit global branch history register is XORed with the uppermost n bits of the m PC bits.</li>
<li>Make a prediction. Use <strong>index</strong> to get the branch‚Äôs counter from the prediction table. If the counter value is greater than or equal to <strong>2</strong>, then the branch is predicted <em>taken</em>, else it is predicted <em>not-taken</em>.</li>
<li>Update the branch predictor based on the branch‚Äôs actual outcome. The branch‚Äôs counter in the prediction table is incremented if the branch was taken, decremented if the branch was nottaken. The counter <em>saturates </em>at the extremes (<strong>0</strong> and <strong>3</strong>), however.</li>
<li>Update the global branch history register. Shift the register right by 1 bit position, and place the branch‚Äôs actual outcome into the most-significant bit position of the register.</li>
</ul>
<strong>Figure 2.&nbsp; Gshare branch predictor. </strong>

<h2>3.2.&nbsp;&nbsp;&nbsp; ECE 563 students only: Hybrid branch predictor</h2>
Model a <strong>hybrid predictor</strong> that selects between the <em>bimodal</em> and the <em>gshare</em> predictors, using a chooser table of 2<em><sup>k</sup></em> 2-bit counters. All counters in the chooser table are initialized to <strong>1</strong> at the beginning of the simulation.

&nbsp;

<u>Steps:</u>

When you get a branch from the trace file, there are six top-level steps:

<ul>
<li>Obtain two predictions, one from the <em>gshare</em> predictor (follow steps 1 and 2 in Section 3.1.2) and one from the <em>bimodal</em> predictor (follow steps 1 and 2 in Section 3.1.1).</li>
<li>Determine the branch‚Äôs <strong>index</strong> into the chooser table. The index for the chooser table is bit <strong><em>k</em>+1</strong> to bit <strong>2</strong> of the branch PC (<em>e.</em>, as before, discard the lowest two bits of the PC).</li>
<li>Make an overall prediction. Use <strong>index</strong> to get the branch‚Äôs chooser counter from the chooser table. If the chooser counter value is greater than or equal to <strong>2</strong>, then use the prediction that was obtained from the <em>gshare</em> predictor, otherwise use the prediction that was obtained from the <em>bimodal</em></li>
<li>Update the selected branch predictor based on the branch‚Äôs actual outcome. Only the branch predictor that was selected in step 3, above, is updated (if <em>gshare</em> was selected, follow step 3 in Section 3.1.2, otherwise follow step 3 in Section 3.1.1).</li>
<li>Note that the <em>gshare‚Äôs </em>global branch history register must always be updated, even if <em>bimodal</em> was selected (follow step 4 in Section 3.1.2).</li>
<li>Update the branch‚Äôs chooser counter using the following rule:</li>
</ul>
&nbsp;

<table width="638">
<tbody>
<tr>
<td rowspan="2" width="160">&nbsp;

&nbsp;
</td>
<td width="159"></td>
<td width="160"><strong>Results from predictors</strong></td>
<td width="160"><strong>:</strong></td>
</tr>
<tr>
<td width="159"><strong><em>both incorrect or </em></strong>

<strong><em>both correct </em></strong>
</td>
<td width="160"><strong><em>gshare correct, bimodal incorrect</em></strong></td>
<td width="160"><strong><em>bimodal correct, gshare incorrect </em></strong></td>
</tr>
<tr>
<td width="160"><strong>Chooser counter update policy:</strong></td>
<td width="159">no change</td>
<td width="160">increment

(but saturates at 3)
</td>
<td width="160">decrement

(but saturates at 0)
</td>
</tr>
</tbody>
</table>
&nbsp;

<h1>4.&nbsp; Inputs to Simulator</h1>
<h2>4.1.&nbsp; Traces</h2>
Traces are posted on the Moodle site. The simulator reads a trace file in the following format:

&nbsp;

&lt;hex branch PC&gt; t|n

&lt;hex branch PC&gt; t|n ‚Ä¶

&nbsp;

Where: o &lt;hex branch PC&gt; is the address of the branch instruction in memory. This field is used to index into predictors.

o ‚Äút‚Äù indicates the branch is <u>actually taken</u> (Note! <em><u>Not</u></em> that it is predicted taken!). Similarly, ‚Äún‚Äù indicates the branch is actually not-taken.

&nbsp;

Example:

&nbsp;

00a3b5fc t

00a3b604 t

00a3b60c n ‚Ä¶

<h2>4.2.&nbsp; Command-line arguments to the simulator</h2>
The simulator executable built by your Makefile must be named ‚Äúsim‚Äù (the Makefile is discussed in Section 6).

&nbsp;

Your simulator must accept command-line arguments as follows: (Note: &lt;tracefile&gt; is the filename of the input trace.)

&nbsp;

<em>To simulate a bimodal predictor</em>:&nbsp;&nbsp; <strong>sim bimodal &lt;M2&gt; &lt;tracefile&gt;</strong>, where M2 is the number of PC bits used to index the bimodal table.

&nbsp;

<em>To simulate a gshare predictor</em>:&nbsp;&nbsp; <strong>sim gshare &lt;M1&gt; &lt;N&gt; &lt;tracefile&gt;</strong>, where M1 and N are the number of PC bits and global branch history register bits used to index the gshare table, respectively.

&nbsp;

<em>To simulate a hybrid predictor</em>:&nbsp;&nbsp; <strong>sim hybrid &lt;K&gt; &lt;M1&gt; &lt;N&gt; &lt;M2&gt; &lt;tracefile&gt;</strong>, where K is the number of PC bits used to index the chooser table, M1 and N are the number of PC bits and global branch history register bits used to index the gshare table (respectively), and M2 is the number of PC bits used to index the bimodal table.

&nbsp;

<h1>5.&nbsp; Outputs from Simulator</h1>
Your simulator should output the following:

(<u>See Section 6 regarding the formatting of these outputs and validating your simulator.)</u>

&nbsp;

<ol>
<li>The simulator command (which indicates the branch predictor configuration and trace file).</li>
<li>The following measurements:
<ol>
<li>number of predictions (<em>e.</em>, number of dynamic branches in the trace)</li>
<li>number of mispredictions (predicted <em>taken</em> when <em>not-taken</em>, or predicted <em>not-taken</em> when<em> taken</em>)</li>
<li>misprediction rate (# mispredictions/# predictions)</li>
</ol>
</li>
<li>The final contents of the branch predictor.</li>
</ol>
&nbsp;

&nbsp;

<h1>6.&nbsp; Submit, Validate, and Self-Grade with Gradescope</h1>
Sample simulation outputs are provided on the Moodle site. These are called ‚Äúvalidation runs‚Äù. <strong>Refer to the validation runs to see how to format the outputs of your simulator.</strong>

&nbsp;

<strong>You must submit, validate, and self-grade<a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a> your project using Gradescope.</strong> Here is how Gradescope (1) receives your project (zip file), (2) compiles your simulator (Makefile), and (3) runs and checks your simulator (arguments, print-to-console requirement, and ‚Äúdiff -iw‚Äù):

&nbsp;

<ol>
<li><strong>How Gradescope receives your project: zip file.</strong> While you are developing your simulator, you may continuously submit new zip files to Gradescope containing the latest version of your project. The latest submission is the one that is considered for your grade. Gradescope will accept a zip file consisting of three things: your source code, a Makefile to compile your source code, and your project report. In the early stages of your project, before creating the report, your zip file will have only source code and a Makefile. Once the report is completed, your zip file will contain everything.
<ul>
<li><u>Report (included in the zip file once available):</u> The report must be a PDF file named ‚Äúreport.pdf‚Äù located at the top level of the zip file, because that is what Gradescope looks for when checking completeness of the submission. <em>See Section 7 and the <u>required report template</u> in Moodle for the required contents of the report.</em></li>
<li><u>Makefile:</u> The Makefile must be at the top level of the zip file, because Gradescope runs ‚Äúmake‚Äù with the expectation that the Makefile is at the top level.</li>
<li><u>Source code:</u> Whether your source code is at the top level of the zip file or in directories below the top level, your Makefile must be designed to compile your source code, accordingly.</li>
</ul>
</li>
</ol>
&nbsp;

<ol start="2">
<li><strong>How Gradescope compiles your simulator: Makefile.</strong> Along with your source code, you must provide a Makefile that automatically compiles the simulator. This Makefile must create a simulator named ‚Äúsim‚Äù. An example Makefile is posted on the Moodle site, which you can copy and modify for your needs.</li>
</ol>
&nbsp;

<ol start="3">
<li><strong>How Gradescope runs and checks your simulator: arguments, print-to-console requirement, ‚Äúdiff -iw‚Äù, and timeout.</strong>
<ul>
<li>Your simulator executable (created by your Makefile) must be named ‚Äúsim‚Äù and take command-line arguments in the manner specified in Section 4.2, because Gradescope assumes these things.</li>
<li>Your simulator must print outputs to the console (<em>e.</em>, to the screen), because Gradescope assumes this.</li>
<li>Your output must match the validation runs both <u>numerically</u> and in terms of <u>formatting</u>, because Gradescope runs ‚Äúdiff -iw‚Äù to compare your output with the correct output. The iw flags tell ‚Äúdiff‚Äù to treat upper-case and lower-case as equivalent and to ignore the amount of whitespace between words. Therefore, you do not need to worry about the exact number of spaces or tabs as long as there is some whitespace where the validation</li>
</ul>
</li>
</ol>
&nbsp;

runs have whitespace. Note, however, that extra or missing blank lines are NOT ok: ‚Äúdiff -iw‚Äù does not ignore extra or missing blank lines. ‚Ä¢ Gradescope‚Äôs autograder has a timeout for compiling the simulator and running all tests. The default timeout is 10 minutes. This is usually ample time for this course. If the autograder times out for your project (very inefficient simulator or a bug that causes deadlock), you will see a grade of zero for that submission. Please see Section 9.2 regarding optimizing run time. Also seek advice from the instructor and TAs, as needed.

<h1>7.&nbsp;&nbsp;&nbsp; Grading Breakdown, Experiments, and Report</h1>
See the <u>required report template</u> in Moodle for the grading breakdown, experiments, and report contents.&nbsp; Use the report template as the basis for the report that you submit (insert graphs, fill in answers to questions, <em>etc</em>.).

<h1>8.&nbsp; Penalties</h1>
&nbsp;

Various deductions (out of 100 points):

&nbsp;

<strong>-1 point</strong> for each day (24-hour period) late, according to the Gradescope timestamp. The late penalty is pro-rated on an hourly basis: -1/24 point for each hour late. We will use the ‚Äúceiling‚Äù function of the lateness time to get to the next higher hour, <em>e.g.</em>, ceiling(10 min. late) = 1 hour late, ceiling(1 hr, 10 min. late) = 2 hours late, and so forth. <strong>For this second project, Gradescope will accept late submissions no more than one week after the deadline. The goal of this policy is to encourage forward progress for other work in the class. </strong>

&nbsp;

<strong>See Section 1.1 for penalties and sanctions for academic integrity violations. </strong>

&nbsp;

<h1>9.&nbsp; Advice on backups and run time</h1>
<h2>9.1.&nbsp; Keeping backups</h2>
It is good practice to frequently make backups of all your project files, including source code, your report, <em>etc</em>.&nbsp; You can backup files to another hard drive (your NFS B: drive in your NCSU account, home PC, laptop ‚Ä¶ keep consistent copies in multiple places) or removable media

(flash drive, <em>etc</em>.).

<h2>9.2.&nbsp; Run time of simulator</h2>
<em>Correctness</em> of your simulator is of paramount importance. That said, making your simulator <em>efficient</em> is also important because you will be running many experiments: many branch predictor configurations and multiple traces. Therefore, you will benefit from implementing a simulator that is reasonably fast.

&nbsp;

One simple thing you can do to make your simulator run faster is to compile it with a high optimization level. The example Makefile posted on the Moodle site includes the ‚ÄìO3 optimization flag.

&nbsp;

Note that, when you are debugging your simulator in a debugger (such as gdb), it is recommended that you compile without ‚ÄìO3 and with ‚Äìg. Optimization includes register allocation. Often, register-allocated variables are not displayed properly in debuggers, which is why you want to disable optimization when using a debugger. The ‚Äìg flag tells the compiler to include symbols (variable names, <em>etc</em>.) in the compiled binary. The debugger needs this information to recognize variable names, function names, line numbers in the source code, <em>etc</em>. When you are done debugging, recompile with ‚ÄìO3 and without ‚Äìg, to get the most efficient simulator again.

&nbsp;

As mentioned in Section 6, another reason for being wary of excessive run times is Gradescope‚Äôs autograder timeout.

<a href="#_ftnref1" name="_ftn1">[1]</a> The mystery runs component of your grade will not be published until we release it.&nbsp; The report will be manually graded by the TAs.
